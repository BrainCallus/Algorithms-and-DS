# Dynamic Programming
## A. Минимум на стеке

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Вам требуется реализовать структуру данных, выполняющую следующие операции:
1. Добавить элемент x в конец структуры.
2. Удалить последний элемент из структуры.
3. Выдать минимальный элемент в структуре.

### Входные данные:
В первой строке входного файла задано одно целое число n — количество операций (1≤n≤$`10^6`$). В следующих n
 строках заданы сами операции. В i–ой строке число $`t_i`$ — тип операции (1, если операция добавления. 2, если операция удаления. 3, если операция минимума).
Если задана операция добавления, то через пробел записано целое число x — элемент, который следует добавить в структуру ($−10^9≤x≤10^9$). 
Гарантируется, что перед каждой операцией удаления или нахождения минимума структура не пуста.

### Выходные данные:
Для каждой операции нахождения минимума выведите одно число — минимальный элемент в структуре. Ответы разделяйте переводом строки.

### Пример

**входные данные**
```c++
8
1 2
1 3
1 -3
3
2
3
2
3
```

**выходные данные**
```c++
-3
2
2
```


## B. Шарики

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

В одной компьютерной игре игрок выставляет в линию шарики разных цветов. Когда образуется непрерывная цепочка из трех и более шариков одного цвета, она удаляется из линии. Все шарики при этом сдвигаются друг к другу, и ситуация может повториться.

Напишите программу, которая по данной ситуации определяет, сколько шариков будет сейчас уничтожено. Естественно, непрерывных цепочек из трех и более одноцветных шаров в начальный момент может быть не более одной.

### Входные данные:
Даны количество шариков в цепочке (не более $10^5$) и цвета шариков (от 0 до 9, каждому цвету соответствует свое целое число).

### Выходные данные:
Требуется вывести количество шариков, которое будет уничтожено.

### Примеры 

**входные данные**
```c++
5 1 3 3 3 2
```
**выходные данные**
```c++
3
```
**входные данные**
```c++
10 3 3 2 1 1 1 2 2 3 3
```
**выходные данные**
```c++
10
```


## C. Астроград

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

В Астрополисе прошел концерт популярной группы Астроград. За пару дней до концерта перед кассой выстроилась огромная очередь из людей, желающих туда попасть. Изначально очередь была пуста. В каждый из `n` моментов времени происходило следующее:
 1. В очередь пришел новый человек с уникальным номером `id`, он встает в очередь последним.
 2. Человеку, стоящему спереди очереди, удалось купить билет. Он уходит.
 3. Человеку, стоящему последнему в очереди, надоело ждать. Он уходит.
 4. Человек с уникальным номером `q` хочет знать, сколько людей стоит в очереди спереди него.
 5. Очередь хочет знать, человек с каким уникальным номером стоит сейчас первым и задерживает всех

 Вам необходимо написать программу, которая умеет обрабатывать описанные события.

### Входные данные:
В первой строке дано целое число `n` ( $1 \leq n \leq 10^5$) — количество событий. В каждой из следующих n строк дано описание событий: номер события, а также число `id` ( $1 \leq id \leq 10^5$) для событий типа 1 и число `q` для событий типа 4. События происходили в том порядке, в каком они описаны во входном файле. Гарантируется корректность всех событий.

### Выходные данные:
Требуется вывести количество шариков, которое будет уничтожено.

### Пример

**входные данные**
```c++
7
1 1
5
1 3
3
2
1 2
4 2
```

**выходные данные**
```c++
1
0
```

### Примечание:
В примере из условия происходили следующие события:

 1. В очередь пришел человек с id = 1. Очередь: [ 1 ]
 2. Первым в очереди стоит человек с id = 1. Очередь: [ 1 ]
 3. В очередь пришел человек с id = 3. Очередь: [ 1, 3 ]
 4. Последнему в очереди надоело стоять и он уходит. Очередь: [ 1 ]
 5. Первому в очереди удалось купить билет и он уходит. Очередь: [ ]
 6. В очередь пришел человек с id = 2. Очередь: [ 2 ]
 7. q = 2 хочет знать, сколько человек стоит перед ним. Очередь: [ 2 ]


## D. Гоблины и шаманы

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Гоблины Мглистых гор очень любят ходить к своим шаманам. Так как гоблинов много, к шаманам часто образуются очень длинные очереди. А поскольку много гоблинов в одном месте быстро образуют шумную толпу, которая мешает шаманам проводить сложные медицинские манипуляции, последние решили установить некоторые правила касательно порядка в очереди.

Обычные гоблины при посещении шаманов должны вставать в конец очереди. Привилегированные же гоблины, знающие особый пароль, встают ровно в ее середину, причем при нечетной длине очереди они встают сразу за центром.

Так как гоблины также широко известны своим непочтительным отношением ко всяческим правилам и законам, шаманы попросили вас написать программу, которая бы отслеживала порядок гоблинов в очереди.

### Входные данные:
В первой строке входных данный записано число N ( $1  \leq  N  \leq  5 \cdot 10^5$) - количество запросов к программе. Следующие N строк содержат описание запросов в формате:
 * ,,+ i" - гоблин с номером i (1  ≤  i  ≤  N) встает в конец очереди.
 * ,,* i" - привилегированный гоблин с номером i встает в середину очереди.
 * ,,-" - первый гоблин из очереди уходит к шаманам. Гарантируется, что на момент такого запроса очередь не пуста.

 ### Выходные данные:
 Для каждого запроса типа ,,-" программа должна вывести номер гоблина, который должен зайти к шаманам.

 ### Пример

**входные данные**
```c++
7
+ 1
+ 2
-
+ 3
+ 4
-
-
```

**выходные данные**
```c++
1
2
3
```


## E. Постфиксная запись

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел `A` и `B` записывается как `A B +`. Запись `B C + D *` обозначает привычное нам `(B + C) * D`, а запись `A B C + D * +` означает `A + (B + C) * D`. Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.

Дано выражение в обратной польской записи. Определите его значение.

### Входные данные:
В единственной строке записано выражение в постфиксной записи, содержащее однозначные числа и операции +, -, *. Строка содержит не более 100 чисел и операций.

### Выходные данные:
Необходимо вывести значение записанного выражения. Гарантируется, что результат выражения, а также результаты всех промежуточных вычислений по модулю меньше $2^{31}$.

### Пример

**входные данные**
```c++
8 9 + 1 7 - *
```

**выходные данные**
```c++
-102
```


## F. Stack Sorting

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Given two stacks A and B. Initially stack A contains integers from 1 to n in some order, and stack B is empty. You can make two types of operations:

 1. `push`: take the top element from the stack A and move it into stack B,
 2. `pop`: take the top element from the stack B and print it to the output stream.

 Your task is to print all the elements of stack A in sorted order.

### Входные данные:
The first line contains integer n ( $1 ≤ n ≤ 2000$). The second line contains n integers, elements in stack A, the leftmost element being the top of the stack.

### Выходные данные:
Print the sequence of operations that print all elements in sorted order. If there is no solution, print _impossible_.

### Примеры 

**входные данные**
```c++
5
5 3 1 2 4
```
**выходные данные**
```c++
push
push
push
pop
push
pop
pop
push
pop
pop
```
**входные данные**
```c++
3
2 3 1
```
**выходные данные**
```c++
impossible
```



## G. Система непересекающихся множеств

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Реализуйте систему непересекающихся множеств. Кроме того, вам нужно будет найти для множества минимум, максимум, и размер.

Изначально каждый элемент находится в своем собственном множестве.

### Входные данные:
Первая строка ввода содержит целое число n — количество элементов в наборе (1≤n≤300000).

Каждая из следующих строк содержит одну операцию. Существует два типа операций:
 * `union x y`: объединить множества, содержащие элементы `x` и `y`.
 * `get x`: найти множество, содержащее элемент `x`.

### Выходные данные:
Для каждой операции `get x` выведите минимум, максимум и размер множества, содержащего элемент `x`.

### Пример 

**входные данные**
```c++
5
union 1 2
get 3
get 2
union 2 3
get 2
union 1 3
get 5
union 4 5
get 5
union 4 1
get 5
```
**выходные данные**
```c++
3 3 1
1 2 2
1 3 3
5 5 1
4 5 2
1 5 5
```


## H. Подсчет опыта

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

В очередной онлайн игре игроки, как обычно, сражаются с монстрами и набирают опыт. Для того, чтобы сражаться с монстрами, они объединяются в кланы. После победы над монстром, всем участникам клана, победившего его, добавляется одинаковое число единиц опыта. Особенностью этой игры является то, что кланы никогда не распадаются и из клана нельзя выйти. Единственная доступная операция — объединение двух кланов в один.

Поскольку игроков стало уже много, вам поручили написать систему учета текущего опыта игроков.

### Входные данные:
В первой строке входного файла содержатся числа n (1 ≤ n ≤ 200000) и m 1 ≤ m ≤ 200000 — число зарегистрированных игроков и число запросов.

В следующих m строках содержатся описания запросов. Запросы бывают трех типов:
 * `join X Y` — объединить кланы, в которые входят игроки X и Y (если они уже в одном клане, то ничего не меняется).
 * `add X V` — добавить V единиц опыта всем участникам клана, в который входит игрок X (1 ≤ V ≤ 100).
 * `get X` — вывести текущий опыт игрока X.

Изначально у всех игроков 0 опыта и каждый из них состоит в клане, состоящим из него одного.

### Выходные данные:
Для каждого запроса `get X` выведите текущий опыт игрока X.

### Пример 

**входные данные**
```c++
3 6
add 1 100
join 1 3
add 1 50
get 1
get 2
get 3
```
**выходные данные**
```c++
150
0
50
```


## J. Кузнечик собирает монеты

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Кузнечик прыгает по столбикам, расположенным на одной линии на равных расстояниях друг от друга. Столбики имеют порядковые номера от 1 до n. В начале Кузнечик сидит на столбике с номером 1 и хочет добраться до столбика с номером n. Он может прыгнуть вперед на расстояние от 1 до k столбиков, считая от текущего.

На каждом столбике Кузнечик может получить или потерять несколько золотых монет (для каждого столбика это число известно). Определите, как нужно прыгать Кузнечику, чтобы собрать наибольшее количество золотых монет. Учитывайте, что Кузнечик не может прыгать назад

### Входные данные:
В первой строке вводятся два натуральных числа: n и k (3≤n≤10000, 1≤k≤10000), разделённые пробелом. Во второй строке записаны через пробел n−2 целых числа – количество монет, которое Кузнечик получает на каждом столбике, от 2-го до n−1-го. Если это число отрицательное, Кузнечик теряет монеты. Гарантируется, что все числа по модулю не превосходят 10000.

### Выходные данные:
В первой строке программа должна вывести наибольшее количество монет, которое может собрать Кузнечик. Во второй строке выводится число прыжков Кузнечика, а в третьей строке – номера всех столбиков, которые посетил Кузнечик (через пробел в порядке возрастания).

Если правильных ответов несколько, выведите любой из них.

### Примеры 

**входные данные**
```c++
5 3
2 -3 5
```
**выходные данные**
```c++
7
3
1 2 4 5 
```
**входные данные**
```c++
10 3
-13 -2 -14 -124 -9 -6 -5 -7
```
**выходные данные**
```c++
-16
4
1 3 6 8 10 
```
**входные данные**
```c++
12 5
-5 -4 -3 -2 -1 1 2 3 4 5
```
**выходные данные**
```c++
14
7
1 6 7 8 9 10 11 12  
```


## K. Черепаха и монеты

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Черепаха хочет переползти из левого верхнего угла поля размером n на m клеток (2≤n,m≤1000) в правый нижний. За один шаг она может переместиться на соседнюю клетку вправо или на соседнюю клетку вниз. Кроме того, проходя через каждую клетку, Черепаха получает (или теряет) несколько золотых монет (это число известно для каждой клетки).

Определите, какое максимальное количество монет может собрать Черепаха по пути и как ей нужно идти для этого.

### Входные данные:
В первой строке вводятся два натуральных числа: n и m (2≤n, m≤1000), разделённые пробелом. В каждой из следующих n строк записаны через пробел по m чисел $a_{ij}(|a_{ij}|\leq 10)$, которые обозначают количество монет, получаемых Черепашкой при проходе через каждую клетку. Если это число отрицательное, Черепашка теряет монеты.

### Выходные данные:
В первой строке программа должна вывести наибольшее количество монет, которое может собрать Черепаха. Во второй строке без пробелов выводятся команды, которые нужно выполнить Черепахе: буква `'R'` (от слова right) обозначает шаг вправо, а буква `'D'` (от слова down) — шаг вниз.

### Примеры 

**входные данные**
```c++
3 3
0 2 -3
2 -5 7
1 2 0
```
**выходные данные**
```c++
6
RRDD
```
**входные данные**
```c++
4 5
4 5 3 2 9
4 6 7 5 9
5 2 5 -3 -10
3 5 2 9 3
```
**выходные данные**
```c++
41
RDRDDRR 
```


## L. Наибольшая возрастающая подпоследовательность

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Пусть $a_1, a_2, ..., a_n$ — числовая последовательность. Длина последовательности — это количество элементов этой последовательности. Последовательность $a_{i_1}, a_{i_2}, ..., a_{i_k}$ называется подпоследовательностью последовательности a, если $1 ≤ i_1 < i_2 < ... < i_k ≤ n$. Последовательность a называется возрастающей, если $a_1 < a_2 < ... < a_n$.

Вам дана последовательность, содержащая n целых чисел. Найдите ее самую длинную возрастающую подпоследовательность.

### Входные данные:
В первой строке задано одно число n (1 ≤ n ≤ 2000) — длина подпоследовательности. В следующей строке задано n целых чисел $a_i$ $( - 10^9 ≤ a_i ≤ 10^9)$ — элементы последовательности.

### Выходные данные:
В первой строке выведите число k — длину наибольшей возрастающей подпоследовательности. В следующей строке выведите k чисел — саму подпоследовательность.

### Примеры 

**входные данные**
```c++
8
1 4 1 5 3 3 4 2
```
**выходные данные**
```c++
3
1 4 5 
```
**входные данные**
```c++
3
1 2 3
```
**выходные данные**
```c++
3
1 2 3 
```


## M. Ход конем

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Шахматная ассоциация решила оснастить всех своих сотрудников такими телефонными номерами, которые бы набирались на кнопочном телефоне ходом коня. Например, ходом коня набирается телефон 340-49-27. При этом телефонный номер не может начинаться ни с цифры 0, ни с цифры 8. 

![image](https://github.com/BrainCallus/Algorithms-and-DS/assets/113727970/d87ee65d-a108-47ee-b72d-a42a8d603e90)

Напишите программу, определяющую количество телефонных номеров длины n, набираемых ходом коня. Поскольку таких номеров может быть очень много, выведите ответ по модулю $10^9$.

### Входные данные:
Во входном файле записано целое число n (1 ≤ n ≤ 100).

### Выходные данные:
Выведите в выходной файл искомое количество телефонных номеров по модулю $10^9$.

### Примеры 

**входные данные**
```c++
1
1 4 1 5 3 3 4 2
```
**выходные данные**
```c++
8
```
**входные данные**
```c++
2
```
**выходные данные**
```c++
16
```


## N. Расстояние по Левенштейну

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дана текстовая строка. С ней можно выполнять следующие операции:

 1. Заменить один символ строки на другой символ.
 2. Удалить один произвольный символ.
 3. Вставить произвольный символ в произвольное место строки.

Например, при помощи первой операции из строки «СОК» можно получить строку «СУК», при помощи второй операции — строку «ОК», при помощи третьей операции — строку «СТОК».

Минимальное количество таких операций, при помощи которых можно из одной строки получить другую, называется стоимостью редактирования или расстоянием Левенштейна.

Определите расстояние Левенштейна для двух данных строк.

### Входные данные:
Программа получает на вход две строки, длина каждой из которых не превосходит 1000 символов, строки состоят только из заглавных латинских букв.

### Выходные данные:
Требуется вывести одно число — расстояние Левенштейна для данных строк.

### Пример

**входные данные**
```c++
ABCDEFGH
ACDEXGIH
```
**выходные данные**
```c++
3
```


## O. Кафе

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 64 мегабайта

ввод: стандартный ввод

вывод: стандартный вывод

Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок: при каждой покупке более чем на 100 рублей покупатель получает купон, дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).

Однажды Пете на глаза попался прейскурант на ближайшие n дней. Внимательно его изучив, он решил, что будет обедать в этом кафе все n дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были минимальны. Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые Пете следует воспользоваться купонами.

### Входные данные:
В первой строке входного файла записано целое число n (0 ≤ n ≤ 100). В каждой из последующих n строк записано одно целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число, не превосходящее 300.

### Выходные данные:
В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа $k_1$ и $k_2$ — количество купонов, которые останутся неиспользованными у Пети после этих n дней и количество использованных им купонов соответственно.

В последующих $k_2$ строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами. Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение $k_1$ максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе). Если таких решений несколько, выведите любое из них.

### Примеры

**входные данные**
```c++
5
110
40
120
110
60
```
**выходные данные**
```c++
260
0 2
3
5
```
**входные данные**
```c++
3
110
110
110
```
**выходные данные**
```c++
220
1 1
2
```


## P. Удаление скобок 2.0

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дана строка, составленная из круглых, квадратных и фигурных скобок. Определите, какое наименьшее количество символов необходимо удалить из этой строки, чтобы оставшиеся символы образовывали правильную скобочную последовательность.

### Входные данные:
Во входном файле записана строка из круглых, квадратных и фигурных скобок. Длина строки не превосходит 100 символов.

### Выходные данные:
Выведите строку максимальной длины, являющейся правильной скобочной последовательностью, которую можно получить из исходной строки удалением некоторых символов.

### Пример

**входные данные**
```c++
([)]
```
**выходные данные**
```c++
[]
```


## Замощение доминошками

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Вам дана прямоугольная сетка из квадратных ячеек. Символ 'X' представляет собой уже покрытую ячейку, символ '.' - это ячейка, которую еще нужно покрыть.

Вы хотите покрыть все ячейки '.', непересекающимися доминошками 2×1. Найдите количество способов сделать это. Два способа считаются различными, если две ячейки покрыты одним и тем же домино в одном замощении и двумя разными домино в другом замощении.

### Входные данные:
Первая строка содержит числа n и m (1≤n,m≤12). Следующие n строк содержат по m символов — описание доски.

### Выходные данные:
Выведите число замощений доминошками.

### Примеры

**входные данные**
```c++
2 2
..
..
```
**выходные данные**
```c++
2
```
**входные данные**
```c++
3 3
...
.X.
...
```
**выходные данные**
```c++
2
```
**входные данные**
```c++
3 3
...
...
..X
```
**выходные данные**
```c++
4
```

