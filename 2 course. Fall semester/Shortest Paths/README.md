# Shortest Paths
## A. Флойд

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами. Гарантируется, что в графе нет циклов отрицательного веса.

### Входные данные:
В первой строке вводится единственное число N(1≤N≤100) — количество вершин графа. В следующих N строках по N чисел задается матрица смежности графа (j-ое число в i-ой строке — вес ребра из вершины i в вершину j). Все числа по модулю не превышают 100. На главной диагонали матрицы — всегда нули.

### Выходные данные:
Выведите N строк по N чисел — матрицу расстояний между парами вершин, где j-ое число в i-ой строке равно весу кратчайшего пути из вершины i в j

### Пример

**входные данные**
```c++
4
0 5 9 100
100 0 2 8
100 100 0 7
4 100 100 0
```

**выходные данные**
```c++
0 5 7 13 
12 0 2 8 
11 16 0 7 
4 9 11 0
```


## B. Кратчайший путь – 2

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан неориентированный связный взвешенный граф. Найдите кратчайшее расстояние от первой вершины до всех вершин.

### Входные данные:
В первой строке входного файла два числа: n и m(2≤n≤30000,1≤m≤400000), где n — количество вершин графа, а m — количество ребер.

Следующие m строк содержат описание ребер. Каждое ребро задается стартовой вершиной, конечной вершиной и весом ребра. Вес каждого ребра — неотрицательное целое число, не превосходящее $10^4$.
### Выходные данные:
Выведите n чисел — для каждой вершины кратчайшее расстояние до нее.
### Пример

**входные данные**
```c++
4 5
1 2 1
1 3 5
2 4 8
3 4 1
2 3 3
```
**выходные данные**
```c++
0 1 4 5
```


## C. Цикл отрицательного веса

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан ориентированный граф. Определите, есть ли в нем цикл отрицательного веса, и если да, то выведите его.

### Входные данные:
Во входном файле в первой строке число N (1 ≤ N ≤ 100) — количество вершин графа. В следующих N строках находится по N чисел — матрица смежности графа. Все веса ребер не превышают по модулю 10 000. Если ребра нет, то соответствующее число равно 100 000.
### Выходные данные:
В первой строке выходного файла выведите «YES», если цикл существует или «NO» в противном случае. При его наличии выведите во второй строке количество вершин в искомом цикле и в третьей строке — вершины входящие в этот цикл в порядке обхода

### Пример

**входные данные**
```c++
2
0 -1
-1 0
```

**выходные данные**
```c++
YES
2
2 1 
```


## D. Кратчайший путь длины K

ограничение по времени на тест: 4 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан ориентированный граф. Найдите кратчайшие пути, состоящие из K рёбер, от S до всех вершин.

### Входные данные:
В первой строке дано целых четыре целых числа: 1⩽N,M⩽$10^4$ — количества вершин и рёбер, 0⩽K⩽100 — количество рёбер в кратчайших путях, 1⩽S⩽N — начальная вершина.

В последующих M строках даны тройки целых чисел $a_i$, $b_i$, w — начало и конец ребра, а также его вес (1⩽$a_i$,$b_i$⩽N,$−10^5$⩽w⩽$10^5$)

### Выходные данные:
Выведите ровно N чисел по одному в строке. i-е число — длина минимального пути из ровно K рёбер из S в i, или −1, если пути не существует.
### Примеры

**входные данные**
```c++
3 3 1 1
1 2 100
2 3 300
1 3 2
```

**выходные данные**
```c++
-1
100
2
```

**входные данные**
```c++
3 3 2 1
1 2 100
2 3 300
1 3 2
```

**выходные данные**
```c++
-1
-1
400
```


## E. Кратчайшие пути

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Вам дан взвешенный ориентированный граф и вершина s в нём. Для каждой вершины графа u выведите длину кратчайшего пути от вершины s до вершины u.

### Входные данные:
Первая строка входного файла содержит три целых числа n, m, s — количество вершин и ребёр в графе и номер начальной вершины соответственно (2 ≤ n ≤ 2 000, 1 ≤ m ≤ 5 000).

Следующие m строчек описывают рёбра графа. Каждое ребро задаётся тремя числами — начальной вершиной, конечной вершиной и весом ребра соответственно. Вес ребра — целое число, не превосходящее $10^{15}$ по абсолютной величине. В графе могут быть кратные рёбра и петли.

### Выходные данные:
Выведите n строчек — для каждой вершины u выведите длину кратчайшего пути из s в u. Если не существует пути между s и u, выведите «*». Если не существует кратчайшего пути между s и u, выведите «-».
### Пример

**входные данные**
```c++
6 7 1
1 2 10
2 3 5
1 3 100
3 5 7
5 4 10
4 3 -18
6 1 -1
```

**выходные данные**
```c++
0
10
-
-
-
*
```


## F. В поисках утраченного кефира

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Школьник Вася хочет найти запасы спрятанного кефира. По легенде, кефир находится в домиках a, b или c. Вася хочет проверить каждый из этих трёх домиков, потратив на это минимальное количество времени.

Местность, в которой находится Вася, представляет собой n домиков, пронумерованных числами от 1 до n. Некоторые из домиков соединены дорогами, по которым можно ходить в обе стороны. Время прохождения i-й дороги составляет wi секунд. Путём в графе называется непустая последовательность вершин, такая что все соседние вершины соединены дорогой. Требуется помочь Васе найти путь, содержащий вершины a, b, c, такой что суммарное время прохождения всех дорог на пути минимально. При этом, если мы прошли по какой-то дороге дважды (или более), то и время её прохождения следует учитывать соответствующее количество раз. Начинать свой путь Вася может из любой вершины.

Гарантируется, что a, b, c — попарно различные домики.

### Входные данные:
В первой строке ввода записаны два числа n и m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 200 000) — количество домиков в ЛКШ и дорог между ними соответственно.

Следующие m строк содержат описания дорог, по одному в строке. Каждая из дорог задаётся тройкой чисел $u_i$, $v_i$, $w_i$ (1 ≤ $u_i$, $v_i$ ≤ n, 1 ≤ $w_i$ ≤ $10^9$) — номерами соединённых домиков и временем, затрачиваемым на прохождение данной дороги. По каждой дороге разрешено ходить в обе стороны. Гарантируется, что любая пара домиков соединена не болee чем одной дорогой. Также гарантируется, что нет дороги, соединяющей домик с самим собой.

В последней строке записаны три попарно различных числа a, b, c (1 ≤ a, b, c ≤ n).

### Выходные данные:
Выведите одно целое число — минимальное возможное время, которое нужно затратить на прохождение пути, содержащего домики a, b и c. Если пути, содержащего все три домика не существует, то выведите -1.
### Примеры

**входные данные**
```c++
4 4
1 2 3
2 3 1
3 4 7
4 2 10
1 4 3
```
**выходные данные**
```c++
11
```
**входные данные**
```c++
4 2
1 2 10
2 3 5
1 2 4
```
**выходные данные**
```c++
-1
```

### Примечание
В первом примере путь 1–2–3–4 является минимальным (11 секунд). Например, путь 1–2–4–3 не подходит, так как занимает больше времени (20 секунд), а путь 3–4–2 не подходит, так как домик a оказывается не посещенным.

Во втором примере не существует способа добраться от домика b до домика c, поэтому искомого пути не существует.


## G. Бемби

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Существует страна, в которой n городов. Города пронумерованы от 1 до n. Также в этой стране существуют двунаправленные дороги. Каждая дорога соединяет пару городов. Для каждого i, автомобильная дорога i соединяет города $a_i$ и $b_i$.

Бемби — это олень, который любит путешествовать по дорогам. Движение по дороге i(в любом направлении) занимает у оленя $d_i$ минут. Бемби ненавидит города и из-за этого никогда в них не задерживается.

Бемби начинает путешествие из города номер 1. Через t минут он желает оказаться в городе n. Вы должны узнать, может ли Бемби достигнуть город n ровно через t минут.

### Входные данные:
Первая строка содержит два целых числа n и m — количество городов и дорог в стране (1≤n,m≤50).

Следующие m строк описывают дороги. Каждая строка состоит из чисел $a_i$, $b_i$ и $d_i$ — концы дороги и ее длина (1≤$a_i$,$b_i$≤n; 1≤$d_i$≤$10^4$).

Последняя строка содержит целое число t — количество минут, за которое Бемби желает добраться до города n(1≤t≤$10^{18}$).

### Выходные данные:
Выведите "Possible" если Бемби сможет достичь цели ровно за t минут, иначе выведите "Impossible".
### Примеры

**входные данные**
```c++
3 3
1 3 7
1 2 6
2 3 5
11
```
**выходные данные**
```c++
Possible
```

**входные данные**
```c++
3 3
1 3 7
1 2 6
2 3 5
25
```
**выходные данные**
```c++
Possible
```

**входные данные**
```c++
2 1
1 2 1
9
```
**выходные данные**
```c++
Possible
```

**входные данные**
```c++
2 1
2 1 1
1000000000000000000
```
**выходные данные**
```c++
Impossible
```

**входные данные**
```c++
4 3
1 3 10
1 2 10
2 3 10
1000
```
**выходные данные**
```c++
Impossible
```


## H. Система гонцов

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Система оповещения древней ЛКШ о новостях представляет из себя n постов, соединенных между собой m двусторонними дорогами. Как только один пост получает какую-то информацию, из него выходит бесконечно много гонцов по всем смежным дорогам, доставляя информацию в соседние посты, из которых, в свою очередь, информация распространяется в соседние с ними, и так далее, пока она не распространится на все достижимые посты.

К сожалению, некоторые из дорог — плохие, и под дождем превращаются в болото. Гонцы не очень любят перемещаться по болоту, поэтому если за окном идет дождь, гонец сначала дождется окончания дождя на посту, и только после этого выдвинется дальше.

Тем не менее, если в момент времени t хорошая погода, и гонец вышел на дорогу длины w, а сразу после этого начался дождь, профессиональная этика не позволит гонцу развернуться обратно, и в момент времени t+w сообщение все-таки будет доставлено в пост на конце дороги. Аналогично, если дождь начинается, когда гонец уже прошел часть дороги, он не прекращает движение, и доходит до конечного пункта за то же время, что и в хорошую погоду.

Для всех плохих дорог известно, что на них хорошая погода в одни и те же отрезки времени. Каждый отрезок времени задается парой чисел $x_$i и $y_i$, и означает, что в моменты времени между $x_$i и $y_i$ включительно гонцы могут начать движение по плохим дорогам.

Для проверки эффективности системы вас просят определить, в какой первый момент времени сообщение достигнет поста b, если изначально оно появится на посту a в момент времени $t_0$, или сказать, что сообщение вообще не дойдет до поста v.

### Входные данные:
В первой строке ввода даны три целых числа n, m и k — количество постов и дорог между ними, а также количество отрезков времени, в которые на плохих дорогах хорошая погода (2⩽n⩽$10^5$; 1⩽m⩽$10^6$, 1⩽k⩽$10^5$).

В i-й из следующих m строк через пробел даны четыре целых числа $u_i$, $v_i$, $w_i$ и $q_i$. Первые два числа $u_i$ и $v_i$ — номера постов, соединяемых i-й дорогой (1⩽$u_i$,$v_i$⩽n; $u_i$≠$v_i$). Число $w_i$ — время, за которое гонец проходит дорогу целиком (1⩽wi⩽$10^9$). Число $q_i$ равно 1, если дорога является плохой, и 0 иначе.

В каждой из следующих k строк записаны по два целых числа $x_i$, $y_i$ — моменты времени, между которыми (включительно) погода хорошая (1⩽$x_i$⩽$y_i$⩽$10^{18}; $y_{i−1}<x_i$ для всех i).

В последней строке ввода даны три целых числа a, b и $t_0$ — номера стартового и конечного постов, а также время появления сообщения на стартовом посту (1⩽a,b⩽n; 1⩽$t_0$⩽$10^{18}$).

### Выходные данные:
Выведите единственное целое число T, означающее, что первый гонец доберется от поста a до поста b, начав движение в момент времени $t_0$, за время T. Если сообщение не дойдет до b никогда, выведите «-1» (без кавычек).

### Примеры

**входные данные**
```c++
2 1 1
1 2 1 0
2 3
1 2 3
```
**выходные данные**
```c++
1
```

**входные данные**
```c++
6 8 2
1 2 1 0
3 5 5 0
3 4 1 1
2 4 2 0
3 6 3 1
4 6 1 0
5 6 1 1
1 6 1 1
6 6
39 40
2 5 8
```
**выходные данные**
```c++
32
```

## I. Функция Гранди

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан ориентированный ациклический граф. Посчитайте функцию Гранди для каждой стартовой вершины.
### Входные данные:
На первой строке будут даны числа n и m — количество вершин и рёбер в графе (1≤n,m≤100000). На следующих m строках содержится по два числа x и y (1≤x,y≤n).

Учтите, что в графе могут быть кратные рёбра.
### Выходные данные:
Выведите n чисел — значение функции Гранди для каждой стартовой вершины.
### Примеры

**входные данные**
```c++
3 3
1 2
2 3
1 3
```
**выходные данные**
```c++
2
1
0
```
**входные данные**
```c++
2 1
2 1
```
**выходные данные**
```c++
0
1
```

## J. Лабиринт знаний

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: maze.in

вывод: maze.out

Участникам сборов подарили билеты на аттракцион "Лабиринт знаний". Лабиринт представляет собой N комнат, занумерованных от 1 до N, между некоторыми из которых есть двери. Когда человек проходит через дверь, показатель его знаний изменяется на определенную величину, фиксированную для данной двери. Вход в лабиринт находится в комнате 1, выход — в комнате N. Каждый участник сборов проходит лабиринт ровно один раз и наибрает некоторое количество знаний (при входе в лабиринт этот показатель равен нулю). Ваша задача — показать наилучший результат.

### Входные данные:
Первая строка входного файла содержит целые числа N (1 ≤ N ≤ 2 000) — количество комнат и M (1 ≤ M ≤ 10 000) — количество дверей. В каждой из следующих M строк содержится описание двери — номера комнат, из которой она ведет и в которую она ведет (через дверь в лабиринте можно ходить только в одну сторону), а также целое число, которое прибавляется к количеству знаний при прохождении через дверь (это число по модулю не превышает 10 000). Двери могут вести из комнаты в нее саму, между двумя комнатами может быть более одной двери.
### Выходные данные:
В выходной файл выведите ":)" — если можно пройти лабиринт и получить неограниченно большой запас знаний, ":(" — если лабиринт пройти нельзя, и максимальное количество набранных знаний в противном случае.

### Примеры

**входные данные**
```c++
2 2
1 2 5
1 2 -5
```
**выходные данные**
```c++
5
```

## K. Космическое строительство

ограничение по времени на тест: 5 секунды

ограничение по памяти на тест: 512 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Исследователь космоса Алексей хочет построить базу на новой планете, которую он недавно открыл. Для того чтобы база считалась построенной, на ней должно быть возведено t
зданий, i-е здание он планирует возводить в i -й день. Для постройки каждого здания необходимо принести на домашнюю планету с других планет ресурсы нескольких видов в строго определенной последовательности (возможно, какой-то ресурс нужно будет принести более одного раза, но принести сразу двойную порцию нельзя, то есть придется сделать ровно столько заходов, сколько единиц ресурса требуется).

Всего различных видов ресурсов $k$. Все планеты в системе располагаются по окружности и пронумерованы от 1 до $n$ , на $i$-й планете располагается ресурс под номером $a_i$ , а также телепорт с параметром $b_i$ (планета с номером 1 — домашняя, и на ней тоже есть ресурс и телепорт).

Путешествовать по планетам можно следующим образом:
1. отнести найденный на $i$-й планете ресурс под номером $a_i$ на домашнюю планету и немедленно вернуться назад (на $i$-ю планету); 
2. воспользовавшись телепортом, можно переместиться с $i$-й планеты ровно на $b_i$ планет вперед по кругу (так, при $n=7$ равенство $b_1$=3 означает, что с первой планеты можно переместиться на четвертую, а $b_6=2$ — что с шестой планеты можно попасть на первую); 
3. переместиться в следующую по кругу планету, на которой располагается тот же ресурс, что и на $i$-й.

Выясните, какие здания из списка Алексей сможет построить, пользуясь указанной системой перемещений, а какие нет. Напомним, что каждый день Алексей строит только одно здание. Разумеется, каждый день Алексей начинает на домашней планете номер 1.

Для постройки здания необходимо принести на планету ресурсы **строго в том же порядке, в котором они перечислены**. Так, если для постройки здания необходимы ресурсы [1,2,1], то нельзя построить здание, принеся сначала две единицы ресурса 1 , а затем ресурс 2 .

### Входные данные:
В первой строке через пробелы заданы три целых числа $k$, $n$ и $t$ — количество различных ресурсов, количество планет в системе и количество зданий, которые необходимо построить $(1 \leq k \leq 100; 1 \leq n,t \leq 10^6)$.

Во второй строке через пробел перечислены $n$ целых чисел $a_i$ — номера ресурсов, расположенных на соответствующих планетах $(1 \leq a_i \leq k)$. В третьей строке в том же формате перечислены числа $b_i$ — параметры телепортов для каждой планеты $0 \leq b_i \leq n$).

В следующих $t$ парах строк находятся описания $s_i$ — зданий, которые требуется построить. Описание $i$-го здания занимает две строки, на первой из которых дано единственное целое число $|s_i|$ — длина последовательности ресурсов, необходимых для постройки $(1 \leq |s_i| \leq 10^6)$, а на второй через пробел перечислены $|s_i|$
целых чисел — номера ресурсов, из которых строится здание.

Гарантируется, что сумма длин всех последовательностей не превосходит $10^6$, а номера ресурсов корректны, то есть лежат от 1 до $k$.
### Выходные данные:
Выведите $t$ строк. На $i$-й строке выведите «YES» (без кавычек), если здание $s_i$ можно построить, и «NO» иначе. Каждая буква ответа может быть как прописной, так и строчной.
### Пример

**входные данные**
```c++
3 4 2
3 1 2 1
1 0 1 3
3
3 2 1
3
1 2 3
```
**выходные данные**
```c++
YES
NO
```
### Примечание:
В примере первое здание («3 2 1») строится путешествием через следующую комбинацию планет: получаем ресурс «3» на планете 1, путешествуем телепортом на планету 2, путешествуем на планету 4 с тем же ресурсом, чтобы сдвинуть на четвертую ячейку, снова пользуемся телепортом, чтобы попасть на планету 3 , затем забираем оттуда ресурс, пользуемся телепортом, и забираем ресурс с планеты 4 .

Второе здание построить не получится, так как на единственную планету с ресурсом '3', первую, никак не попасть из других ячеек.


## L. Транспортировка

ограничение по времени на тест: 2 секунды

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Компания "Яндекс" решила подарить всем школьникам и преподавателям Школы Олимпиадой Подготовки оригинальные крyжки. К сожалению, количество необходимых кружек оказалось столь велико, что изготовитель доставил кружки в офис Яндекса в самый последний момент. До открытия смены в Иннополисе осталось всего 24 часа.

О плачевном состоянии дорог по пути до города ходят легенды — в частности, на многих разбитых дорогах действует ограничение на вес автомобиля. Соответственно, от нагруженности машины зависит возможность воспользоваться тем или иным маршрутом, тяжёлой машине может потребоваться ехать в обход.

Уже совершенно очевидно, что все кружки не поспеют к открытию. Чтобы спасти ситуацию, отвезите первым рейсом максимально возможное количество кружек успев до начала открытия смены.

### Входные данные:
В первой строке находятся целые числа n (2 ≤ n ≤ 500) и m — количество городов и количество двусторонних дорог, соответственно.

В следующих m строках описываются дороги.

В каждой строке находятся целые числа $a_i$, $b_i$, $t_i$, $w_i$  — соответственно два города, ею соединяемые, время на проезд по ней в минутах и ограничение на вес автомобиля в граммах $(t_i \leq 1440, w_i \leq 10^9, 1 \leq a_i, b_i \leq n)$

Между каждой парой городов есть не более одной дороги.

Кроме того, известно, что офис Яндекса имеет номер 1, а Иннополис — номер n, одна кружка весит 100 грамм, а пустой грузовик — 3 тонны.
### Выходные данные:
Выведите одно число — максимальное количество кружек, которое можно привезти, потратив не более 24 часов.
### Пример

**входные данные**
```c++
3 3
1 2 10 3000220
2 3 20 3000201
1 3 1 3000099
```
**выходные данные**
```c++
2
```

